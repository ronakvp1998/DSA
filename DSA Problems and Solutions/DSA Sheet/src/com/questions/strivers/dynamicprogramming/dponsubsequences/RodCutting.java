package com.questions.strivers.dynamicprogramming.dponsubsequences;
//https://takeuforward.org/data-structure/rod-cutting-problem-dp-24/
//Rod Cutting Problem
//We are given a rod of size ‚ÄòN‚Äô. It can be cut into pieces.
//Each length of a piece has a particular price given by the price array.
//Our task is to find the maximum revenue that can be generated by selling the rod after cutting( if required) into pieces.
//price[] = {2,5,7,8,10} N = 5
//O/P=> answer = 12, price(2 + 5 + 5) one piece of length 1 and two pieces of length 2
import java.util.Arrays;
public class RodCutting {
    // 1Ô∏è‚É£ Recursive Approach (Brute Force)
    private static int rodCuttingRecursive(int index, int[] price, int length) {
        // Base Case: When index is 0, we can only cut rod in pieces of length 1
        // Take as many as we can (length / 1), multiply with price[0]
        if (index == 0) {
            return length * price[0];
        }

        // Option 1: Do not cut at this length
        int notCut = rodCuttingRecursive(index - 1, price, length);

        // Option 2: Cut at current length (index + 1)
        int cut = 0;
        int rodLength = index + 1;
        if (rodLength <= length) {
            // Take current piece and stay on same index
            cut = price[index] + rodCuttingRecursive(index, price, length - rodLength);
        }

        return Math.max(cut, notCut); // return max of both options
    }
    // Time Complexity: O(2^N) ‚Äî exponential due to branching choices
    // Space Complexity: O(N) ‚Äî recursion stack depth

    // 2Ô∏è‚É£ Memoization (Top-Down DP)
    private static int rodCuttingMemo(int index, int[] price, int length, int[][] dp) {
        // Base case
        if (index == 0) {
            return length * price[0];
        }

        if (dp[index][length] != -1)
            return dp[index][length];

        int notCut = rodCuttingMemo(index - 1, price, length, dp);
        int cut = 0;
        int rodLength = index + 1;
        if (rodLength <= length) {
            cut = price[index] + rodCuttingMemo(index, price, length - rodLength, dp);
        }

        return dp[index][length] = Math.max(cut, notCut);
    }
    // Time Complexity: O(N * N) ‚Äî each (index, length) computed once
    // Space Complexity: O(N * N) + O(N) recursion stack

    // 3Ô∏è‚É£ Tabulation (Bottom-Up DP)
    private static int rodCuttingTabulation(int[] price, int N) {
        int[][] dp = new int[N][N + 1]; // dp[i][l] = max value using pieces up to length i+1 and total length l

        // Base case: only using first rod (length 1)
        for (int l = 0; l <= N; l++) {
            dp[0][l] = l * price[0]; // use as many 1-length rods as possible
        }

        for (int i = 1; i < N; i++) {
            int rodLength = i + 1; // actual length of the current piece
            for (int l = 0; l <= N; l++) {
                int notCut = dp[i - 1][l]; // do not take current rod
                int cut = 0;
                if (rodLength <= l) {
                    cut = price[i] + dp[i][l - rodLength]; // take and stay
                }
                dp[i][l] = Math.max(cut, notCut); // max of both
            }
        }

        return dp[N - 1][N]; // answer is for full length N using all pieces
    }
    // Time Complexity: O(N * N)
    // Space Complexity: O(N * N)

    // 4Ô∏è‚É£ Space Optimization
    private static int rodCuttingSpaceOptimized(int[] price, int N) {
        int[] prev = new int[N + 1]; // prev[l] = max value for length l using pieces up to previous index

        // Initialize with only 1-length rods
        for (int l = 0; l <= N; l++) {
            prev[l] = l * price[0];
        }

        for (int i = 1; i < N; i++) {
            int[] curr = new int[N + 1];
            int rodLength = i + 1;
            for (int l = 0; l <= N; l++) {
                int notCut = prev[l]; // don't take current rod
                int cut = 0;
                if (rodLength <= l) {
                    cut = price[i] + curr[l - rodLength]; // take and stay on same i
                }
                curr[l] = Math.max(cut, notCut);
            }
            prev = curr; // update prev for next iteration
        }

        return prev[N]; // max value for full length
    }
    // Time Complexity: O(N * N)
    // Space Complexity: O(N)

    // üîç Main method to test all approaches
    public static void main(String[] args) {
        int[] price = {2, 5, 7, 8, 10}; // price[i] = price for rod of length i+1
        int N = 5; // total rod length

        // 1. Recursive
        System.out.println("Recursive: " + rodCuttingRecursive(N - 1, price, N));

        // 2. Memoization
        int[][] dp = new int[N][N + 1];
        for (int[] row : dp) Arrays.fill(row, -1);
        System.out.println("Memoization: " + rodCuttingMemo(N - 1, price, N, dp));

        // 3. Tabulation
        System.out.println("Tabulation: " + rodCuttingTabulation(price, N));

        // 4. Space Optimization
        System.out.println("Space Optimized: " + rodCuttingSpaceOptimized(price, N));
    }
}
