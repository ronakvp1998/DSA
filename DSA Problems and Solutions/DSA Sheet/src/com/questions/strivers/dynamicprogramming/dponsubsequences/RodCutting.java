package com.questions.strivers.dynamicprogramming.dponsubsequences;

import java.util.Arrays;

/**
 * ==================================================================================================
 * PROBLEM: ROD CUTTING PROBLEM (GeeksForGeeks / LeetCode Variation)
 * ==================================================================================================
 * PROBLEM STATEMENT:
 * We are given a rod of size 'N'. It can be cut into pieces.
 * Each length of a piece has a particular price given by the price array.
 * * price[i] represents the price of a rod piece of length 'i+1'.
 * * Our task is to find the maximum revenue that can be generated by selling the rod after cutting.
 *
 * EXAMPLE:
 * Input: N = 5, price[] = {2, 5, 7, 8, 10}
 * Output: 12
 * Explanation:
 * - Length 1 costs 2.
 * - Length 2 costs 5.
 * - Best Strategy: Cut into pieces of length 2, 2, 1.
 * - Value: 5 + 5 + 2 = 12.
 *
 * KEY INSIGHT (UNBOUNDED KNAPSACK):
 * This is structurally identical to the Unbounded Knapsack Problem.
 * - Items: Rod pieces of lengths 1 to N.
 * - Weight: Length of the piece.
 * - Value: Price of the piece.
 * - Knapsack Capacity: Total Rod Length N.
 * - Supply: Infinite (we can cut multiple pieces of the same length).
 * ==================================================================================================
 */
public class RodCutting {

    public static void main(String[] args) {
        int[] price = {2, 5, 7, 8, 10}; // price[i] is for length i+1
        int N = 5; // Total length of rod

        System.out.println("Prices: " + Arrays.toString(price));
        System.out.println("Rod Length: " + N);
        System.out.println("--------------------------------------------------");

        // 1. Recursive Approach
        System.out.println("1. Recursion       : " + rodCuttingRecursive(N - 1, price, N));

        // 2. Memoization Approach
        int[][] dp = new int[N][N + 1];
        for (int[] row : dp) Arrays.fill(row, -1);
        System.out.println("2. Memoization     : " + rodCuttingMemo(N - 1, price, N, dp));

        // 3. Tabulation Approach
        System.out.println("3. Tabulation      : " + rodCuttingTabulation(price, N));

        // 4. Space Optimized Approach (Single 1D Array)
        System.out.println("4. Space Optimized : " + rodCuttingSpaceOptimized(price, N));
    }

    /**
     * ----------------------------------------------------------------------
     * APPROACH 1: RECURSION (BRUTE FORCE)
     * ----------------------------------------------------------------------
     * LOGIC:
     * Try to cut a piece of length `index + 1` from the rod.
     * Choices:
     * 1. Not Cut: Move to the next smaller piece size (index - 1).
     * 2. Cut: Take profit `price[index]`, subtract length `index + 1` from total length N.
     * * STAY at `index` because we might want another piece of this same length.
     *
     * COMPLEXITY:
     * - Time: O(2^N) -> Exponential.
     * - Space: O(N) -> Recursion stack.
     */
    private static int rodCuttingRecursive(int index, int[] price, int n) {
        // Base Case: We are at index 0 (Rod length 1)
        // We can simply fill the remaining length 'n' with pieces of length 1.
        if (index == 0) {
            return n * price[0];
        }

        // Choice 1: Do not cut this length
        int notCut = rodCuttingRecursive(index - 1, price, n);

        // Choice 2: Cut this length (if valid)
        int cut = Integer.MIN_VALUE;
        int rodLength = index + 1;

        if (rodLength <= n) {
            // Stay at same index (index) to allow multiple cuts of same length
            cut = price[index] + rodCuttingRecursive(index, price, n - rodLength);
        }

        return Math.max(cut, notCut);
    }

    /**
     * ----------------------------------------------------------------------
     * APPROACH 2: MEMOIZATION (TOP-DOWN DP)
     * ----------------------------------------------------------------------
     * LOGIC:
     * Cache results of (index, length) to avoid re-calculating.
     *
     * COMPLEXITY:
     * - Time: O(N * N) -> States are Index * Length.
     * - Space: O(N * N) + Stack.
     */
    private static int rodCuttingMemo(int index, int[] price, int n, int[][] dp) {
        if (index == 0) {
            return n * price[0];
        }

        if (dp[index][n] != -1) return dp[index][n];

        int notCut = rodCuttingMemo(index - 1, price, n, dp);

        int cut = Integer.MIN_VALUE;
        int rodLength = index + 1;

        if (rodLength <= n) {
            cut = price[index] + rodCuttingMemo(index, price, n - rodLength, dp);
        }

        return dp[index][n] = Math.max(cut, notCut);
    }

    /**
     * ----------------------------------------------------------------------
     * APPROACH 3: TABULATION (BOTTOM-UP DP)
     * ----------------------------------------------------------------------
     * LOGIC:
     * dp[i][len] = Max profit using pieces 0..i to make total length 'len'.
     *
     * COMPLEXITY:
     * - Time: O(N * N)
     * - Space: O(N * N)
     */
    private static int rodCuttingTabulation(int[] price, int N) {
        int[][] dp = new int[N][N + 1];

        // 1. Base Case (Index 0: Rod Length 1)
        for (int len = 0; len <= N; len++) {
            dp[0][len] = len * price[0];
        }

        // 2. Iterate
        for (int i = 1; i < N; i++) {
            for (int len = 0; len <= N; len++) {

                int notCut = dp[i - 1][len]; // Value from row above

                int cut = Integer.MIN_VALUE;
                int rodLength = i + 1;

                if (rodLength <= len) {
                    // Value from SAME row (Unbounded logic)
                    cut = price[i] + dp[i][len - rodLength];
                }

                dp[i][len] = Math.max(cut, notCut);
            }
        }

        return dp[N - 1][N];
    }

    /**
     * ----------------------------------------------------------------------
     * APPROACH 4: SPACE OPTIMIZED (SINGLE 1D ARRAY)
     * ----------------------------------------------------------------------
     * LOGIC:
     * In Tabulation, `dp[i][len]` depends on:
     * 1. `dp[i-1][len]` (Prev Row -> Current value in 1D array)
     * 2. `dp[i][len - rodLength]` (Same Row, Left -> Updated value in 1D array)
     *
     * We iterate `len` from Left-to-Right. The value `dp[len - rodLength]` will
     * be the updated value for the CURRENT piece, simulating infinite supply.
     *
     *
     * COMPLEXITY:
     * - Time: O(N * N)
     * - Space: O(N) -> Single array
     */
    private static int rodCuttingSpaceOptimized(int[] price, int N) {
        int[] dp = new int[N + 1];

        // 1. Base Case (Index 0: Length 1)
        for (int len = 0; len <= N; len++) {
            dp[len] = len * price[0];
        }

        // 2. Iterate through other rod pieces
        for (int i = 1; i < N; i++) {
            int rodLength = i + 1;

            // Iterate Length Left-to-Right
            for (int len = 0; len <= N; len++) {
                int notCut = dp[len]; // Value from prev iteration

                int cut = Integer.MIN_VALUE;
                if (rodLength <= len) {
                    // Uses updated value (dp[len - rodLength] was just computed)
                    cut = price[i] + dp[len - rodLength];
                }

                dp[len] = Math.max(cut, notCut);
            }
        }

        return dp[N];
    }
}